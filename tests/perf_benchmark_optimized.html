<!DOCTYPE html>
<html>
<body>
<canvas id="starfield" width="1920" height="1080"></canvas>
<script>
    const starfield = document.getElementById('starfield');
    const ctx = starfield.getContext('2d');
    const numStars = 800;
    let stars = [];
    let speed = 20;
    let warp = 0;

    function setup() {
        starfield.width = 1920;
        starfield.height = 1080;
        stars = [];
        for (let i = 0; i < numStars; i++) {
            stars.push({
                x: (Math.random() - 0.5) * starfield.width,
                y: (Math.random() - 0.5) * starfield.height,
                z: Math.random() * starfield.width
            });
        }
    }

    function draw(warpValue) {
        warp = warpValue;
        if (!ctx) return;
        const centerX = starfield.width / 2;
        const centerY = starfield.height / 2;

        ctx.fillStyle = 'black';
        ctx.fillRect(0,0,starfield.width, starfield.height);

        // Update positions first
        for(let i=0; i<numStars; i++) {
            const s = stars[i];
            s.z -= speed;
            if(s.z <= 0) {
                s.x = (Math.random() - 0.5) * starfield.width;
                s.y = (Math.random() - 0.5) * starfield.height;
                s.z = starfield.width;
            }
        }

        // Sort stars by z (descending)
        stars.sort((a, b) => b.z - a.z);

        if (warp > 0) {
            // WARP MODE
            ctx.strokeStyle = `rgba(255,255,255,${warp})`;

            let currentSize = -1;
            let pathEmpty = true;

            // Quantize size to 0.1 for better batching (max size 5.0 -> ~50 buckets)

            for(let i=0; i<numStars; i++) {
                const s = stars[i];
                const k = 128.0 / s.z;
                const px = s.x * k + centerX;
                const py = s.y * k + centerY;

                if(px >= 0 && px < starfield.width && py >= 0 && py < starfield.height) {
                    let rawSize = (1 - s.z / starfield.width) * 5;
                    let size = Math.round(rawSize * 10) / 10;
                    if (size < 0.1) size = 0.1; // Ensure visible

                    if (size !== currentSize) {
                        if (!pathEmpty) {
                            ctx.stroke();
                        }
                        currentSize = size;
                        ctx.lineWidth = size;
                        ctx.beginPath();
                        pathEmpty = true;
                    }

                    ctx.moveTo(px, py);
                    ctx.lineTo(px + (s.x / s.z) * speed * 2, py + (s.y / s.z) * speed * 2);
                    pathEmpty = false;
                }
            }
            if (!pathEmpty) ctx.stroke();

        } else {
            // DOTS MODE
            let currentShade = -1;
            let pathEmpty = true;

            for(let i=0; i<numStars; i++) {
                const s = stars[i];
                const k = 128.0 / s.z;
                const px = s.x * k + centerX;
                const py = s.y * k + centerY;

                if(px >= 0 && px < starfield.width && py >= 0 && py < starfield.height) {
                    let shade = parseInt((1 - s.z / starfield.width) * 255);
                    let size = (1 - s.z / starfield.width) * 5;

                    if (shade !== currentShade) {
                        if (!pathEmpty) {
                            ctx.fill();
                        }
                        currentShade = shade;
                        ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
                        ctx.beginPath();
                        pathEmpty = true;
                    }

                    ctx.rect(px, py, size, size);
                    pathEmpty = false;
                }
            }
            if (!pathEmpty) ctx.fill();
        }
    }

    setup();
    const ITERATIONS = 1000;

    // Benchmark Dots
    const startDots = performance.now();
    for (let i = 0; i < ITERATIONS; i++) {
        draw(0);
    }
    const endDots = performance.now();
    const durationDots = endDots - startDots;
    console.log(`Dots Avg Time: ${(durationDots / ITERATIONS).toFixed(4)} ms`);

    // Benchmark Warp
    const startWarp = performance.now();
    for (let i = 0; i < ITERATIONS; i++) {
        draw(1);
    }
    const endWarp = performance.now();
    const durationWarp = endWarp - startWarp;
    console.log(`Warp Avg Time: ${(durationWarp / ITERATIONS).toFixed(4)} ms`);

    const resultDiv = document.createElement('div');
    resultDiv.id = 'benchmark-results';
    resultDiv.innerText = JSON.stringify({
        dots: durationDots / ITERATIONS,
        warp: durationWarp / ITERATIONS
    });
    document.body.appendChild(resultDiv);

</script>
</body>
</html>
