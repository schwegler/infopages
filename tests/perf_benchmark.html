<!DOCTYPE html>
<html>
<body>
<canvas id="starfield" width="1920" height="1080"></canvas>
<script>
    const starfield = document.getElementById('starfield');
    const ctx = starfield.getContext('2d');
    const numStars = 800;
    const warpThreshold = 0.9;
    let stars = [];
    let speed = 20; // Constant speed for benchmark
    let warp = 0; // Test with warp 0 and warp 1

    function setup() {
        starfield.width = 1920;
        starfield.height = 1080;
        stars = [];
        for (let i = 0; i < numStars; i++) {
            stars.push({
                x: (Math.random() - 0.5) * starfield.width,
                y: (Math.random() - 0.5) * starfield.height,
                z: Math.random() * starfield.width
            });
        }
    }

    function draw(warpValue) {
        warp = warpValue;
        if (!ctx) return;
        const centerX = starfield.width / 2;
        const centerY = starfield.height / 2;

        ctx.fillStyle = 'black';
        ctx.fillRect(0,0,starfield.width, starfield.height);

        ctx.fillStyle = 'white';

        for(let i=0; i<numStars; i++) {
            const s = stars[i];
            s.z -= speed;
            if(s.z <= 0) {
                s.x = (Math.random() - 0.5) * starfield.width;
                s.y = (Math.random() - 0.5) * starfield.height;
                s.z = starfield.width;
            }

            const k = 128.0 / s.z;
            const px = s.x * k + centerX;
            const py = s.y * k + centerY;

            if(px >= 0 && px < starfield.width && py >= 0 && py < starfield.height) {
                let size = (1 - s.z / starfield.width) * 5;
                let shade = parseInt((1 - s.z / starfield.width) * 255);
                ctx.fillStyle = `rgb(${shade},${shade},${shade})`;

                if (warp > 0) {
                    ctx.strokeStyle = `rgba(255,255,255,${warp})`;
                    ctx.lineWidth = size;
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.lineTo(px + (s.x / s.z) * speed * 2, py + (s.y / s.z) * speed * 2);
                    ctx.stroke();
                } else {
                    ctx.fillRect(px,py,size,size);
                }
            }
        }
    }

    setup();
    const ITERATIONS = 1000;

    // Benchmark Dots
    const startDots = performance.now();
    for (let i = 0; i < ITERATIONS; i++) {
        draw(0);
    }
    const endDots = performance.now();
    const durationDots = endDots - startDots;
    console.log(`Dots Avg Time: ${(durationDots / ITERATIONS).toFixed(4)} ms`);

    // Benchmark Warp
    const startWarp = performance.now();
    for (let i = 0; i < ITERATIONS; i++) {
        draw(1);
    }
    const endWarp = performance.now();
    const durationWarp = endWarp - startWarp;
    console.log(`Warp Avg Time: ${(durationWarp / ITERATIONS).toFixed(4)} ms`);

    // Output to body for playwright to read easily
    const resultDiv = document.createElement('div');
    resultDiv.id = 'benchmark-results';
    resultDiv.innerText = JSON.stringify({
        dots: durationDots / ITERATIONS,
        warp: durationWarp / ITERATIONS
    });
    document.body.appendChild(resultDiv);

</script>
</body>
</html>
